---
title: 通读vue文档有感
date: 2023-02-18 02:13:37
permalink: /pages/f8a2a4/
categories:
  - 前端
  - vue学习笔记
tags:
  - 
author: 
  name: Ling HuanLiang
  link: https://github.com/lilling02
---
## 模板引用
这段大家回忆一下什么叫模板引用

```` vue
<script setup>
import { ref, onMounted } from 'vue'

// 声明一个 ref 来存放该元素的引用
// 必须和模板里的 ref 同名
const input = ref(null)

onMounted(() => {
input.value.focus()
})
</script>

<template>
<input ref="input" />
</template>
````

这段才是要说的:

    注意,你只可以在组件挂载后才能访问模板引用.如果你想在模板中的表达式上访问 input,在初次渲染时会是 null.这是因为在初次渲染前这个元素还不存在呢!

    如果你需要侦听一个模板引用 ref 的变化,确保考虑到其值为 null 的情况

当在 v-for 中使用模板引用时,对应的 ref 中包含的值是一个数组

### 函数模板引用
除了使用字符串值作名字,ref attribute 还可以绑定为一个函数,会在每次组件更新时都被调用.该函数会收到元素引用作为其第一个参数:
    ````js
    <input :ref="(el) => { /* 将 el 赋值给一个数据属性或 ref 变量 */ }">
    ````

### 组件上的 ref

如果一个子组件使用的是选项式 API 或没有使用 <script setup>,被引用的组件实例和该子组件的 this 完全一致,这意味着父组件对子组件的每一个属性和方法都有完全的访问权.

使用了 <script setup> 的组件是默认私有的:一个父组件无法访问到一个使用了 <script setup> 的子组件中的任何东西,除非子组件在其中通过 defineExpose 宏显式暴露

### v-if 和 v-show 
文档上对于if 和 show的原理是这么描述的

v-if 是"真实的"按条件渲染,因为它确保了在切换时,条件区块内的事件监听器和子组件都会被销毁与重建.

相比之下,v-show 简单许多,元素无论初始条件如何,始终会被渲染,只有 CSS display 属性会被切换.

v-if 也是惰性的:如果在初次渲染时条件值为 false,则不会做任何事.条件区块只有当条件首次变为 true 时才被渲染.

总的来说,v-if 有更高的切换开销,而 v-show 有更高的初始渲染开销.因此,如果需要频繁切换,则使用 v-show 较好;如果在运行时绑定条件很少改变,则 v-if 会更合适.

看论坛中发现大家有提到一些关键点:
    1.当 v-if 和 v-for 同时存在于一个元素上的时候,v-if 会首先被执行.会导致性能问题.
    2.v-if 他是 组件的销毁与重构 , 销毁重构组件是会触发生命周期的.
    3.如果v-if条件渲染的组件在keep-alive内那么即使条件渲染的条件不成立也不会被卸载.

### watch 和 watchEffet (之前没学,现在记录一下)
watch 只追踪明确侦听的数据源.它不会追踪任何在回调中访问到的东西.另外,仅在数据源确实改变时才会触发回调.watch 会避免在发生副作用时追踪依赖,因此,我们能更加精确地控制回调函数的触发时机.

watchEffect,则会在副作用发生期间追踪依赖.它会在同步执行过程中,自动追踪所有能访问到的响应式属性.这更方便,而且代码往往更简洁,但有时其响应性依赖关系会不那么明确.

### 既然已经说到了watch 那么 复习一下 侦听器和计算属性的区别
简单来说他俩基本都能做到对方能做到的事情,不同之处在于计算属性值会基于其响应式依赖被缓存.

并且在文档里提到:
1. 计算属性默认是只读的.虽然事实是可写,但你应该把它当做只读.因为他是派生状态,每次他依赖的响应式数据发生变化他也就会变化,所以修改他是没有意义的.应该把他当成一个可读的属性.
2. 计算属性的 getter 应只做计算而没有任何其他的副作用,举例来说,不要在 getter 中做异步请求或者更改 DOM!
如果有副作用的需求应该直接使用watch
3. watch不缓存,大量需要watch返回值的时候,应该使用有缓存的计算属性代替

### setup 究竟是什么
setup() 钩子是在组件中使用组合式 API 的入口.

首先大家都知道,在 setup 函数内部可以创建组件的响应式数据,定义组件的方法、计算属性和事件处理函数等.

从生命周期的角度上来理解什么叫入口.组件实例化的时候是先执行setup(),再去执行其他生命周期的.

### 渲染管线 (复习)
从高层面的视角看,Vue 组件挂载时会发生如下几件事:

编译:Vue 模板被编译为渲染函数:即用来返回虚拟 DOM 树的函数.这一步骤可以通过构建步骤提前完成,也可以通过使用运行时编译器即时完成.

挂载:运行时渲染器调用渲染函数,遍历返回的虚拟 DOM 树,并基于它创建实际的 DOM 节点.这一步会作为响应式副作用执行,因此它会追踪其中所用到的所有响应式依赖.

更新:当一个依赖发生变化后,副作用会重新运行,这时候会创建一个更新后的虚拟 DOM 树.运行时渲染器遍历这棵新树,将它与旧树进行比较,然后将必要的更新应用到真实 DOM 上去.
